Project 02 – Scripting in Bash
Samuel Myers: glo455
IS 2043 Fall 2020
October 1st, 2020
Introduction
	This lab was meant to allow students to apply the skills they have picked up with programming to bash script. We were to practice bash scripting by using the Git-Bash terminal we used in the first project for this class, as well as using text editor nano. We were given a guide meant as a tutorial for bash scripting to use and work through as we demonstrated our abilities to work with bash scripting and while applying what we have learned in the past about coding in general. While doing this, we were to also document our work, push our changes onto a repository created on GitHub, where we were to then share our scripts with someone else, and finally we were to submit our repository link from GitHub. 
Process
	It took me a while to figure out how I should start this assignment. I had heard that using a Linux virtual machine would be easier to follow along with for the purpose of this lab. I set one up and everything, but I came into some issues regarding GitHub. I decided to just stick it out with the Git Bash terminal we installed from the last project and work from there. Once I was situated, I used my memory from project one to create a new repository and link it from the GitHub website to the work I was doing on my terminal. When my environment was properly set up, I began my work on the steps outlined by the bash scripting guide. The first step was easy, as it just had us test out some of the features of the shell, features we were already familiar with, like “ls”, “date”, “pwd” and “cal”. The guide moved on to scripting, in which we created a document, “task.sh”, and wrote out commands in it so that by executing the task.sh document, we could run the commands from above all at once, rather than running them separately. Scripting makes it easy to automate processes like this. Unfortunately, the “cal” command does not work in the git bash terminal I was working in, and while I was looking for the right command to accomplish the same thing, I couldn’t find a fix for this. Following the scripting tutorial, we were then introduced to how bash works. We did this by opening up our task.sh file, and writing in “#!/bin/bash”. This is to define the shell interpreter that you want to use to interpret any script. While ours did it automatically, without defining the shell interpreter, it is a good practice to do so. We then moved on to file names and permissions. To start this step, I first began by creating a file named “hello-world.sh”, and then using the command “file hello-world.sh”, which would give me the information of the file, such as if it is a “Bourne-Again shell script” or if it has ASCII text. Next, I copied the "hello-world.sh" file to a new file, which i named "0_xvz". I modified the text using the nano editor to remove the "#!/bin/bash" line from the file, and again used the command "file" on the newly created file. This time, It only showed "ASCII text", rather than displaying the shell or any other information besides text. The next step involved Script Execution. This step involved using the echo command to write the text "date" to a file also named date.sh, and then making it so that the file could run. Originally, the file should not be able to run with just the command "./date.sh". I believe mine worked just fine using the git bash terminal, but i followed along anyway. I used the nano editor to write in the shebang (#!/bin/bash). Then, I used the "chmod +x" command to make the file executable. Doing these steps would help to make a file execute in a linux terminal. By completing these steps, the date.sh file would execute and show the current date. Next, we moved on to work with Relative and Absolute Paths. This was a very simple step that involved navigating through the terminal using the cd commands and either absolute paths that would take us to a certain directory, or relative paths which would take us to another nearby part instead of typing the entire absolute path again. Moving on to the next step, I deleted my old "hello-world.sh" file and made a new version of it with a shebang. It also had the command "echo "Hello World" in it, as a normal hello world file would. Then, using the chmpod command again to make the file executable, I ran the file. The first time i did it, I had an issue running it. It turns out that I had messed up and wrote "hello-world,sh" instead. I quickly rectified the issue and it ran smoothly. The next step involved making a backup file, named "backup.sh", adding the shebang and then adding a tar command to create a tar ball with the home directory saved. I then used the tar command in the terminal. I made sure to change the address from what the tutorial put so that it would work on my computer as well. I ran it too to make sure it worked. Thus, I made a simple backup file, which will be built upon heavily as the guide goes on. The next step had us working with variables, and we were to create a script called welcome.sh with variables such as "greeting", "user", and "day". The former was set as "Welcome", while the latter two were set as variables which depended on who the user was and what the day was. Then, the script would output a welcome message that would welcome the user by name, and proceed to tell the user the date and their bash shell version. I ran the script and was met with my own username and the correct date, so I knew the script had worked just as planned. I also practiced assigning variables with certain values from the terminal, and using simple code to have two variables add up, subtract, etc. After familiarizing myself with how variables worked in bash, I added some variables to my backup script. I added a user variable, as well as an input and output variable, to conduct the backup. The tar command was simplified using the input and output variables, where the input variable represented the first half of the old tar command, and the output represented the second half. I also had an echo command put in, which would tell the user that the backup was done and would print out the details of the backup file. Luckily, I ran into no issue running this command. The next step went more into input and output. We practiced with how input and output can have different responses depending on certain factors, like a text file not existing. We also were introduced to standard error and standard output, the former which occurs when an error happens from an inputted command, and the latter which occurs when a command is successfully carried out. We also were introduced to redirection notation, and we practiced using this redirection notation using some text files we created. With this knowledge, I continued to add to my backup script. This time, I added the redirection notation "2>" to redirect the standard error that would occur every time the file was executred regarding the tar command to a data sink. That way, the standard error message for the tar command would not show anymore. Moving on to the next topic regarding functions, we created a file titled "function.sh", and from there added some sort of function class named "user_details", which would print the user's name and home directory to the screen. I also added a call for the function so that it would make sure to execute the script when the proper command was executed. With this knowledge, I added two functions to my backup script, one named "total_files", which was responsible for reporting the total amount of files in a directory, and one named "total_directories", which was responsible for a similar function as the former, except with directories. I also added two echo statements that would show the amount of files and directories that would be included in the backup. I was able to execute the script this time again, but it took a long while to execute, and it did not show the number of files and directories I had. In addition, some of the messages came up saying it had failed because it did not have permission to the files it was looking over. t worked for the most part besides those two hiccups, and despite looking for fixes, I could not find any that worked for what I needed to accomplish with this git bash script. Moving on to the next step, we just practiced using string comparisons (such as < and >), as well as using numeric comparisons (such as -lt and -gt). When we got familiar with how they worked, we created a text file named "comparison.sh", which we used to write a string and a number comparison. For the string comparison, we had one string assigned to "UNIX" and one assigned to "GNU". Then we wrote code to see if they were equal, and then return a boolean value based on whether or not it was equal. We did the same thing for the number comparison, except with the number variables both being set to 100. When the script was run, a 1 was outputted to the screen for the string comparison, indicating it was false that they were equal, and a 0 was outputted to the string for the number comparison, indicating that it was true that it was equal. The next step got into conditional statements. 
